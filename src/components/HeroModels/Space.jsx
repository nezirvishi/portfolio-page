// src/components/HeroModels/Space.jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Adjusted to add animated galaxy-style points, colors, and bloom
Author: LoÃ¯c Norgeot (https://sketchfab.com/norgeotloic)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/need-some-space-d6521362b37b48e3a82bce4911409303
Title: Need some space?
*/

import React, { useMemo, useRef } from 'react'
import * as THREE from 'three'
import { Points, useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { EffectComposer, SelectiveBloom } from '@react-three/postprocessing'

export function Space(props) {
  const groupRef = useRef()
  const centerLightRef = useRef()
  const { nodes } = useGLTF('models/need_some_space.glb')

  const [positions, colors, starTexture] = useMemo(() => {
    // Clone & center geometry so rotations/scales are around origin
    const geom = nodes.Object_2.geometry.clone()
    geom.center()

    // Copy positions into a fresh Float32Array
    const positions = new Float32Array(geom.attributes.position.array.buffer.slice(0))
    const colors = new Float32Array(positions.length)

    // Distance-based color gradient: reddish near center, bluish further out
    const color = new THREE.Color()
    for (let i = 0; i < positions.length; i += 3) {
      const x = positions[i]
      const y = positions[i + 1]
      const z = positions[i + 2]
      const dist = Math.sqrt(x * x + y * y + z * z)
      const norm = dist / 100 // normalize a bit for nicer variation

      color.setRGB(
        Math.cos(norm),
        THREE.MathUtils.randFloat(0, 0.8),
        Math.sin(norm)
      )
      color.toArray(colors, i)
    }

    // Procedural star sprite so we don't depend on an external image file
    const size = 64
    const canvas = document.createElement('canvas')
    canvas.width = canvas.height = size
    const ctx = canvas.getContext('2d')
    const grd = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2)
    grd.addColorStop(0, 'rgba(255,255,255,1)')
    grd.addColorStop(1, 'rgba(255,255,255,0)')
    ctx.fillStyle = grd
    ctx.fillRect(0, 0, size, size)
    const texture = new THREE.CanvasTexture(canvas)
    texture.anisotropy = 4

    return [positions, colors, texture]
  }, [nodes])

  // Subtle rotation + breathing scale
  useFrame(({ clock }) => {
    const t = clock.getElapsedTime()
    if (groupRef.current) {
      groupRef.current.rotation.z = t / 5
      const s = Math.sin(t / 3.5) + 1.5
      groupRef.current.scale.set(s, s, s)
    }
  })

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <pointLight position={[0, 0, 0]} ref={centerLightRef} intensity={0.5} />
      <Points scale={0.05} positions={positions} colors={colors}>
        <pointsMaterial
          map={starTexture}
          transparent
          depthWrite={false}
          vertexColors
          opacity={0.45}
          depthTest
          size={0.011}
        />
      </Points>
      <EffectComposer autoClear={false}>
        <SelectiveBloom
          intensity={1.6}
          luminanceThreshold={0.001}
          luminanceSmoothing={0.225}
          lights={[centerLightRef]}
        />
      </EffectComposer>
    </group>
  )
}

useGLTF.preload('models/need_some_space.glb')